using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Entity;
using System.Linq;
using System.Text;
using EfModelChecker.Dto.Internal;
using EfModelChecker.Exceptions;

namespace EfModelChecker.Helpers
{
    /// <summary>
    /// Retrieve data about the database schema from the database itself.
    /// </summary>
    /// <remarks>
    /// Use the ANSI standard views to retrieve database metadata.
    /// </remarks>
    internal static class SqlSchemaHelper
    {
        /// <summary>
        /// Retrieve the column metadata for the table.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="tableName"></param>
        /// <param name="schemaName"></param>
        public static IEnumerable<SqlColumn> GetTableSqlColumns(DbContext context, string tableName, string schemaName)
        {
            DataSet ds;

            if (string.IsNullOrEmpty(schemaName))
            {
                ds = SqlQueryHelper.GetData(context.Database.Connection,
                    $"SELECT COLUMN_NAME, IS_NULLABLE, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = '{tableName}'");
            }
            else
            {
                ds = SqlQueryHelper.GetData(context.Database.Connection,
                    $"SELECT COLUMN_NAME, IS_NULLABLE, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = '{tableName}' AND TABLE_SCHEMA = '" + schemaName + "'");
            }

            if (ds == null)
            {
                if (!string.IsNullOrEmpty(schemaName))
                {
                    throw new InvalidDatabaseException($"The database metadata for the {schemaName}.{tableName} table could not be obtained.");
                }

                throw new InvalidDatabaseException($"The database metadata for the {tableName} table could not be obtained.");
            }

            List<SqlColumn> sqlColumns = new List<SqlColumn>();

            foreach (DataRow row in ds.Tables[0].Rows)
            {
                SqlColumn sqlColumn = new SqlColumn
                {
                    ColumnName = row["COLUMN_NAME"].ToString(),
                    IsNullable = row["IS_NULLABLE"].ToString() == "YES"
                };

                // NOTE: The best conversion was attempted based upon documentation online:
                // http://msdn.microsoft.com/en-us/library/cc716729(v=vs.110).aspx
                //
                // Also, during development, a script was created to create a table with every data type.  See the article:
                // http://blogs.msdn.com/b/samlester/archive/2012/08/06/creating-complex-test-databases-creating-tables-with-all-supported-data-types.aspx
                //
                // A Code-First model was then created from this table using the Reverse Engineer Code First wizard.  The model and 
                // entity generated by this was then used to test that all the conversions matched Microsoft.  Should be bullet proof!
                //
                // NOTE: Because this code was developed with EF4, the Spatial data types introduced in SQL Server 2008 such as 
                // Geography are not supported.  The Spatial data types weren't supported in EF until EF5.
                //
                // TODO: Support Spatial data types if they are available.
                // TODO: Support any version of Entity Framework.
                switch (row["DATA_TYPE"].ToString())
                {
                    case "bit":
                        sqlColumn.DataType = sqlColumn.IsNullable ? typeof(bool?) : typeof(bool);
                        break;

                    case "binary":
                    case "varbinary":
                    case "image":
                    case "timestamp":
                        sqlColumn.DataType = typeof(byte[]);
                        break;

                    case "smallmoney":
                    case "money":
                    case "numeric":
                    case "decimal":
                        sqlColumn.DataType = sqlColumn.IsNullable ? typeof(decimal?) : typeof(decimal);
                        break;

                    case "real":
                        sqlColumn.DataType = sqlColumn.IsNullable ? typeof(float?) : typeof(float);
                        break;

                    case "float":
                        sqlColumn.DataType = sqlColumn.IsNullable ? typeof(double?) : typeof(double);
                        break;

                    case "tinyint":
                        sqlColumn.DataType = sqlColumn.IsNullable ? typeof(byte?) : typeof(byte);
                        break;

                    case "smallint":
                        sqlColumn.DataType = sqlColumn.IsNullable ? typeof(short?) : typeof(short);
                        break;

                    case "int":
                        sqlColumn.DataType = sqlColumn.IsNullable ? typeof(int?) : typeof(int);
                        break;

                    case "bigint":
                        sqlColumn.DataType = sqlColumn.IsNullable ? typeof(long?) : typeof(long);
                        break;

                    case "date":
                    case "smalldatetime":
                    case "datetime":
                    case "datetime2":
                        sqlColumn.DataType = sqlColumn.IsNullable ? typeof(DateTime?) : typeof(DateTime);
                        break;

                    case "time":
                        sqlColumn.DataType = sqlColumn.IsNullable ? typeof(TimeSpan?) : typeof(TimeSpan);
                        break;

                    case "datetimeoffset":
                        sqlColumn.DataType = sqlColumn.IsNullable ? typeof(DateTimeOffset?) : typeof(DateTimeOffset);
                        break;

                    case "char":
                    case "nchar":
                    case "varchar":
                    case "nvarchar":
                    case "text":
                    case "ntext":
                    case "xml":
                        sqlColumn.DataType = typeof(string);
                        break;

                    case "uniqueidentifier":
                        sqlColumn.DataType = sqlColumn.IsNullable ? typeof(Guid?) : typeof(Guid);
                        break;

                    case "sql_variant":
                        sqlColumn.DataType = typeof(object);
                        break;

                    default:
                        sqlColumn.DataType = null;
                        break;
                }

                // When it comes to interpreting maximum length, there is a bit of hacking going on here to deal with the 
                // fact that SQL Server itself returns a number of different lengths for the XML, Text, NText, Image and Timestamp
                // columns which don't match the .NET equivalents.
                //
                // Therefore, for these unusual types, set them to what .NET expects so that in the main "comparison" code routine
                // we can just get away with a simple == comparison.
                // 
                // Strings and binary values (which are all we really care about anyway) we can just take as-is.
                switch (row["DATA_TYPE"].ToString())
                {
                    case "xml":
                    case "text":
                    case "ntext":
                    case "image":
                        if (sqlColumn.IsNullable)
                            sqlColumn.MaximumLength = -1;
                        else
                            sqlColumn.MaximumLength = 128;
                        break;

                    case "timestamp":
                        sqlColumn.MaximumLength = 8;
                        break;

                    case "binary":
                    case "varbinary":
                    case "char":
                    case "nchar":
                    case "nvarchar":
                    case "varchar":
                        sqlColumn.MaximumLength = row["CHARACTER_MAXIMUM_LENGTH"].ToString() != string.Empty ?
                            int.Parse(row["CHARACTER_MAXIMUM_LENGTH"].ToString()) : 0;
                        break;

                    default:
                        sqlColumn.MaximumLength = 0;
                        break;
                }

                sqlColumns.Add(sqlColumn);
            }

            return sqlColumns;
        }

        /// <summary>
        /// Retrieve all of the tables.
        /// </summary>
        /// <remarks>
        /// This has to include all of the views as well.
        /// </remarks>
        public static IEnumerable<SqlTable> GetSqlTables(DbContext context)
        {
            // Ignore the sysdiagrams table (which stores SQL server diagrams) if it is there.
            DataSet tablesDataSet = SqlQueryHelper.GetData(context.Database.Connection, "SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME <> 'sysdiagrams' ORDER BY TABLE_NAME");
            DataSet viewsDataSet = SqlQueryHelper.GetData(context.Database.Connection, "SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.VIEWS ORDER BY TABLE_NAME");

            if (tablesDataSet == null || viewsDataSet == null)
                throw new InvalidDatabaseException("The database metadata for all the tables and views could not be obtained.");

            tablesDataSet.Merge(viewsDataSet);

            return
                (from DataRow row in tablesDataSet.Tables[0].Rows
                 select new SqlTable
                 {
                     TableName = row["TABLE_NAME"].ToString(),
                     SchemaName = row["TABLE_SCHEMA"].ToString()
                 })
                 .ToList();
        }

        /// <summary>
        /// Retrieve all of the primary/foreign key relationships.
        /// </summary>
        /// <remarks>
        /// The query is adapted from: https://technet.microsoft.com/en-us/library/aa175805(v=sql.80).aspx
        /// </remarks>
        public static IEnumerable<SqlRelationship> GetSqlRelationships(DbContext context)
        {
            StringBuilder query = new StringBuilder();

            query.Append("SELECT ");
            //query.Append("KCU1.CONSTRAINT_CATALOG AS 'FK_CATALOG', ");
            //query.Append("KCU1.CONSTRAINT_SCHEMA AS 'FK_SCHEMA', ");
            query.Append("KCU1.CONSTRAINT_NAME AS 'FK_NAME', ");
            //query.Append("KCU1.TABLE_CATALOG AS 'TABLE_CATALOG', ");
            //query.Append("KCU1.TABLE_SCHEMA AS 'TABLE_SCHEMA', ");
            query.Append("KCU1.TABLE_NAME AS 'FK_TABLE_NAME', ");
            query.Append("KCU1.COLUMN_NAME AS 'FK_COLUMN_NAME', ");
            //query.Append("KCU2.CONSTRAINT_CATALOG AS 'PK_CATALOG', ");
            //query.Append("KCU2.CONSTRAINT_SCHEMA AS 'PK_SCHEMA', ");
            //query.Append("KCU2.CONSTRAINT_NAME AS 'PK_NAME', ");
            //query.Append("KCU2.TABLE_CATALOG AS 'PK_TABLE_CATALOG', ");
            //query.Append("KCU2.TABLE_SCHEMA AS 'PK_TABLE_SCHEMA', ");
            query.Append("KCU2.TABLE_NAME AS 'PK_TABLE_NAME', ");
            query.Append("KCU2.COLUMN_NAME AS 'PK_COLUMN_NAME', ");
            query.Append("KCU1.ORDINAL_POSITION ");
            query.Append("FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS RC ");

            query.Append("JOIN ");
            query.Append("INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU1 ");
            query.Append("ON KCU1.CONSTRAINT_CATALOG = RC.CONSTRAINT_CATALOG ");
            query.Append("AND KCU1.CONSTRAINT_SCHEMA = RC.CONSTRAINT_SCHEMA ");
            query.Append("AND KCU1.CONSTRAINT_NAME = RC.CONSTRAINT_NAME ");

            query.Append("JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU2 ");
            query.Append("ON KCU2.CONSTRAINT_CATALOG = RC.UNIQUE_CONSTRAINT_CATALOG ");
            query.Append("AND KCU2.CONSTRAINT_SCHEMA = RC.UNIQUE_CONSTRAINT_SCHEMA ");
            query.Append("AND KCU2.CONSTRAINT_NAME = RC.UNIQUE_CONSTRAINT_NAME ");

            query.Append("WHERE KCU1.ORDINAL_POSITION = KCU2.ORDINAL_POSITION ");

            query.Append("ORDER BY PK_TABLE_NAME, ORDINAL_POSITION");

            DataSet ds = SqlQueryHelper.GetData(context.Database.Connection, query.ToString());

            if (ds == null)
                throw new InvalidDatabaseException("The database metadata for all the foreign keys could not be obtained.");

            return (from DataRow row in ds.Tables[0].Rows
                select new SqlRelationship
                {
                    PrimaryKeyTableName = row["PK_TABLE_NAME"].ToString(),
                    PrimaryKeyColumnName = row["PK_COLUMN_NAME"].ToString(),
                    ForeignKeyName = row["FK_NAME"].ToString(),
                    ForeignKeyTableName = row["FK_TABLE_NAME"].ToString(),
                    ForeignKeyColumnName = row["FK_COLUMN_NAME"].ToString(),
                    OrdinalPosition = Convert.ToInt32(row["ORDINAL_POSITION"])
                }).ToList();
        }
    }
}
